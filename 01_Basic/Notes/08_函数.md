## 8.1 函数定义

```go
func myFunc(){
    fmt.Println("called myFunc...")
}
```

## 8.2 普通参数列表

```go
func myFunc(a int, b int){
    fmt.Println("called myFunc...")
    fmt.Printf("a = %d, b = %d\n", a, b)
}
```

## 8.3 不定参数列表

**不定参数：**形参...type表示该函数可接受0个或多个type类型的参数，在函数中通过下标访问。

```go
func myFunc(args ...int){
    for i:= 0; i < len(args); i++ {
        fmt.Printf(args[i])
    }
    fmt.Println("")
}
```

**函数嵌套调用中的不定参数：**

```go
func myFunc(args ...int){
    myFunc(args...)		// 传递全部参数
    myFunc(args[2:]...)	// 传递下标为2（包含）以后的参数
    myFunc(args[:2]...)	// 传递下标为2（不包含）以后的参数
}
```

## 8.4 函数返回值

**单个返回值：**

```go
// 方式一：匿名返回值
func myFunc() int {
	var a, b int = 3, 5
    sum := a + b
    return sum
}

// 方式二：具名返回值
func myFunc() (sum int) {
	var a, b int = 3, 5
    sum = a + b
    return sum
}

// 方式三：具名返回值
func myFunc() (sum int) {
	var a, b int = 3, 5
    sum = a + b
    return
}
```

**多个返回值：**

```go
// 方式一
func myFunc() (a, b, c int){
    a, b, c = 1, 2, 3
    return a, b, c
}

// 方式二
func myFunc() (a, b, c int){
    a, b, c = 1, 2, 3
    return
}
```

## 8.5 函数类型

**函数类型：**将函数作为一种类型来定义变量（函数指针喵）。

```go
// myFunc
func myFunc(a, b int) (sum int) {
	sum = a + b
	return
}

// 函数类型（函数指针）
type FuncType func(a, b int) int

func main() {
	var result FuncType
	result = myFunc
	s := result(3, 5)
	fmt.Println(s)
}
```

## 8.6 匿名函数与闭包

### 8.6.1 匿名函数

实现在一个函数中定义另一个函数，形如```func(){ /* func body */ }```。

**定义匿名函数，绑定到函数类型：**

```go
func main(){
    num := 9
    // 定义函数类型f绑定匿名函数
    f := func() {
        num++
        fmt.Println("this is a unnamed func, the global var num is ", num)
    }
    // 调用匿名函数执行
    f()
    fmt.Println("this is main func, the global var num is ", num)
}
```

**定义匿名函数，直接调用：**

```go
func(a, b int){
    sum := a + b
    fmt.Println("sum = ", sum)
} (3, 6)
```

**定义带有返回值的匿名函数：**

```go
x, y := func(i, j int) (max, min int){
    if i > j {
        max = i
        min = j
    } else {
        max = j
        min = i
    }
    return
} (10, 20)
```

### 8.6.2 闭包

闭包，即指有权访问另一个函数中的变量的函数，所有匿名函数（函数字面量）都是闭包。

> 虽不能在一个函数中直接声明另一个函数，但可以在一个函数中声明一个函数类型的变量，此时实现了闭包。

**闭包的应用：**

```go
/* 使用闭包前 */
func Test() int {
    var x int
    x++
    return x
}

func main() {
    fmt.Println(Test())	// 1
    fmt.Println(Test())	// 1
    fmt.Println(Test())	// 1
}

/* 使用闭包后 */
func Test() func() int {
    var x int
    return func() int {
        x++
        return x
    }
}

func main() {
    f := Test()
    fmt.Println(f())
    fmt.Println(f())
    fmt.Println(f())
}
```

> 被闭包捕获且变量和常量仍在被使用时，不受作用于限制。

## 8.7 延迟调用defer

Go使用关键字defer延迟一个函数（或匿名函数）的执行，defer语句只出现在函数内部。







































