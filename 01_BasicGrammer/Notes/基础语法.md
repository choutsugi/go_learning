学习文档：http://topgoer.com/



# 一、初始Golang

## 01 Go项目结构

- GOPATH

  - bin

  - pkg
  - src
    - xxx.com
      - Project01
      - Project02
      - Project...

## 02 Go程序分析

File：first.go

```go
// 每个go文件必须归属于一个package，包含main函数的文件属于main包。
package main

// 通过import引入一个或多个package。
import (
	"fmt"
	"time"
)

func goFunc(i int) {
	// 调用fmt包中的Println函数。
	fmt.Println("goroutine ", i)
}

func main() {
	for i := 0; i < 1000; i++ {
		go goFunc(i) //开启协程，原生支持并发
	}
	// 调用time包中的Sleep函数。
	time.Sleep(time.Second)
}
```

总结：

- 每个go文件必须归属于一个package，包含main函数的文件属于main包。
- 通过import引入一个或多个package。
- 通过```go run first.go```运行。
- 通过```go build first.go```生成可执行文件。

# 二、基础语法

## 01 数据类型

golang数据类型分为基本数据类型和复杂（派生）数据类型。

### 基本数据类型

基本数据类型包含数值型、字符型、布尔型、字符串型。

- 数值型：
  - 整数型：int、int8、int16、int32、int64、uint、uint8、uint16、uint32、uint64、byte。
  - 浮点型：float32，float64。
- 字符型：无专门的字符型，使用byte保存当个字母字符。
- 布尔型（bool）：
- 字符串型（string）：以UTF-8编码连接单个字符组成。

### 复杂数据类型：

- 指针（Pointer）：
- 数组：
- 结构体（Struct）：
- 管道（Channel）：
- 函数：
- 切片（Slice）：
- 接口（Interface）：
- map：

## 02 变量

## 03 const itoa

## 04 函数

## 05 init

## 06 指针

## 07 defer

## 08 切片

## 09 map

## 10 结构体

### 定义结构体

```go
// 定义结构体
type Book struct {
	title string
	auth  string
}
```

### 结构体赋值

```go
var book Book
book.title = "Golang"
book.auth = "Master"
```

### 结构体作为函数参数

结构体为复杂类型，直接传入函数时函数只会修改其副本，如果需要改变结构体的值，必须传入结构体的指针。

# 三、面向对象

## 01 封装

### 访问权限

Go语言通过标识符首字母大小写来决定访问权限：

- 小写：对其它包隐藏。
- 大写：对其它包开放。

### OOP的实现

对函数绑定结构体指针使其称为结构体的成员函数。

#### 定义结构体

```go
type Hero struct {
	Name  string
	Hp    int
	level int // 小写：private属性
}
```

#### 结构体绑定方法

```go
// 大写：public方法
func (this *Hero) Show() {
	fmt.Println("Name = ", this.Name)
	fmt.Println("Hp = ", this.Hp)
	fmt.Println("Level = ", this.level)
}

func (this *Hero) GetName() string {
	return this.Name
}

func (this *Hero) SetName(newName string) {
	this.Name = newName
}
```

#### 测试

```go
func main() {
	hero := Hero{Name: "Teemo", Hp: 700, level: 1}
	hero.Show()
	hero.SetName("Yasuo")
	name := hero.GetName()
	fmt.Println(name)
}
```

## 02 继承

#### 定义父类结构体并绑定方法

```go
type Human struct {
	name string
	age  int
}

func (this *Human) Eat() {
	fmt.Println("Human.Eat()...")
}

func (this *Human) Walk() {
	fmt.Println("Human.Walk()...")
}
```

#### 定义子类结构体并绑定方法

```go
type SuperMan struct {
	Human // 继承Human
	level int
}

func (this *SuperMan) Fly() {
	fmt.Println("SuperMan.Fly()...")
}

func (this *SuperMan) Print() {
	fmt.Println("name = ", this.name)
	fmt.Println("age = ", this.age)
	fmt.Println("level = ", this.level)
}
```

#### 测试

```go
func main() {
	h := Human{"Mengduo", 22}
	h.Eat()
	h.Walk()

	// s := SuperMan{Human{"Hasaki", 22}, 12}
	var s SuperMan
	s.name = "Hasaki"
	s.age = 22
	s.level = 12

	s.Eat()
	s.Walk()
	s.Fly()
	s.Print()
}
```

## 03 多态

### 多态的实现

- 父类接口。
- 子类实现父类接口的全部接口方法。
- 父类指针指向子类对象。

#### 定义接口

```go
// 接口：本质是指针
type AnimalIF interface {
	Sleep()
	GetColor() string // 颜色
	GetType() string  // 种类
}
```

#### 定义接口实现类

```go
// 接口实现类：Cat
type Cat struct {
	color string
}

func (this *Cat) Sleep() {
	fmt.Printf("Cat is sleep")
}

func (this *Cat) GetColor() string {
	return this.color
}

func (this *Cat) GetType() string {
	return "Cat"
}

// 接口实现类：Dog
type Dog struct {
	color string
}

func (this *Dog) Sleep() {
	fmt.Println("Dog is sleep")
}

func (this *Dog) GetColor() string {
	return this.color
}

func (this *Dog) GetType() string {
	return "Dog"
}
```

#### 测试

```go
func showAnimal(animal AnimalIF) {
	animal.Sleep()
	fmt.Println("color = ", animal.GetColor())
	fmt.Println("type = ", animal.GetType())
}

func main() {
	/*
		var animal AnimalIF // 接口类型：父类指针
		animal = &Cat{"Blue"}
		animal.Sleep()
		animal = &Dog{"Red"}
		animal.Sleep()
	*/

	cat := Cat{"Blue"}
	dog := Dog{"Red"}

	showAnimal(&cat)
	showAnimal(&dog)
}
```

### 通用万能类型

interface{}

#### 测试

```go
func myFunc(arg interface{}) {
	fmt.Println("myFunc is called...")
	fmt.Println(arg)

	// interface{} 的类型断言机制
	value, ok := arg.(string)
	if !ok {
		fmt.Println("arg is not string type!")
	} else {
		fmt.Println("arg is string type! value = ", value)
		fmt.Printf("value type is %T\n", value)
	}
}
```

> 注：空接口的类型断言机制。

# 四、反射

## 01 变量内置pair类型分析

变量内部通过pair对存储（type+value）。

#### 变量结构

- type：
  - static type：
  - concrete type：
- value：

#### 测试

```go
package main

import (
	"fmt"
	"io"
	"os"
)

func main() {
	tty, err := os.OpenFile("./test.txt", os.O_RDWR, 0)

	if err != nil {
		fmt.Println("open file error", err)
		return
	}

	var r io.Reader
	r = tty

	var w io.Writer

	w = r.(io.Writer) // Reader与Writer的pair中的type相同。

	w.Write([]byte("HELLO THIS IS A TEST!!!\n"))
}
```

