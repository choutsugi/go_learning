## 协程

**使用示例：**

```go
func main() {
	
	var wg sync.WaitGroup	// 声明协程管理器
	wg.Add(1)				// 协程开始时协程管理器计数值+1
	go Run(&wg)				// 开始1个协程
	wg.Wait()				// 等待计数为0
}

func Run(wg *sync.WaitGroup){
	fmt.Println("快跑起来！")
	defer wg.Done()			// 协程结束时协程管理器计数值-1
}
```

## 通道

### 无缓冲区的channel

- 先存后取导致死锁。

```go
func main() {
	c1 := make(chan int)	// 无缓冲区的channel
	c1 <- 1					// 存入数据到channel
	fmt.Println(<-c1)		// 从channel取出数据
}
```

- 修改：使用协程。

```go
func main() {
	c1 := make(chan int)	// 无缓冲区的channel
	go func(){
		for i := 0; i < 10; i++ {
			c1<-i			// 存入数据到channel	// 然后到这里
		}
	}()

	for i := 0; i < 10; i++ {
		fmt.Println(<-c1)	// 从channel取出数据	// 程序先到这里
	}
}
```

### 有缓冲区的channel

```go
func main() {
	c1 := make(chan int, 5)	// 缓冲区为5的channel
	go func(){
		for i := 0; i < 10; i++ {
			c1<-i			// 存入数据到channel
		}
	}()

	for i := 0; i < 10; i++ {
		fmt.Println(<-c1)	// 从channel取出数据
	}
}
```

> 分析：协程先存入5个数据，之后主程每取一个，协程则存入一个。

### 只读channel与只写channel

- 这玩意儿跟linux管道的读端和写端一模一样呢。

```go
func main() {
	c1 := make(chan int, 5)

	//var orc <- chan int = c1	// 只读channel
	var owc chan <- int = c1	// 只写channel

	for i := 0; i < 5; i++ {	// 写入
		owc <- i+1
	}

	close(c1)					// 完成写入后关闭（关闭后仍然可以读取）
	for v := range c1 {			// 全部读取：必须先关闭，否则死锁。
		fmt.Println(v)
	}
}
```

## select

- 这是个啥？

```go
func main() {
	ch1 := make(chan int, 1)
	ch2 := make(chan int, 1)
	ch3 := make(chan int, 1)

	ch1 <- 1
	ch2 <- 2
	ch3 <- 3

	select {					// 随缘执行
	case <- ch1:
		fmt.Println("ch1")
	case <- ch2:
		fmt.Println("ch2")
	case <- ch3:
		fmt.Println("ch3")
	default:
		fmt.Println("都不满足")
	}
}
```

## 通过channel实现goroutine通信

```go
func main() {
	ch := make(chan int, 1)

	var readch <- chan int = ch
	var writech chan <- int = ch

	var wg sync.WaitGroup
	wg.Add(1)
	go SetChan(&wg, writech)

	go GetChan(&wg, readch)
	wg.Add(1)
	wg.Wait()
}

func SetChan(wg *sync.WaitGroup, writech chan <- int){
	defer wg.Done()
	for i := 0; i < 10; i++ {
		//fmt.Printf("in SetChan(), set a data: %d\n\n", i)
		writech <- i
	}
}

func GetChan(wg *sync.WaitGroup, readch <- chan int){
	defer wg.Done()
	for i := 0; i < 10; i++ {
		fmt.Printf("in GetChan(), get a data: %d\n", <-readch)
	}
}
```



