##  01 first golang

初识golang：

```go
package main

import (
	"fmt"
	"time"
)

func goFunc(i int) {
	fmt.Println("goroutine ", i)
}

func main() {
	for i := 0; i < 1000; i++ {
		go goFunc(i) //开启协程，原生支持并发
	}
	time.Sleep(time.Second)
}
```

## 02 变量

- 常用四种变量声明方式：
  - 方法一：声明一个变量，默认值为0。
  - 方法二：声明一个变量，指定初始值。
  - 方法三：初始化时省去数据类型，通过值自动匹配当前变量的数据类型。
  - 方法四（常用，仅用于函数体内）：省去var关键字，自动匹配。
- 声明全局变量。
- 同行声明多个变量。
- 多行声明多个变量。

```go
package main

import "fmt"

//声明全局变量
var global_A int = 100
var global_B = 200

// global_C:= 300 //非法，:=仅用于函数体内

func main() {
	//方法一：声明一个变量，默认值为0
	var a int
	fmt.Println("a = ", a)
	fmt.Printf("type of a = %T\n", a)

	//方法二：声明一个变量，指定初始值
	var b int = 100
	fmt.Println("b = ", b)
	fmt.Printf("type of b = %T\n", b)

	var bb string = "abcd"
	fmt.Printf("bb = %s, type of bb = %T\n", bb, bb)

	//方法三：初始化时省去数据类型，通过值自动匹配当前变量的数据类型
	var c = 100
	fmt.Println("c = ", c)
	fmt.Printf("type of c = %T\n", c)

	var cc = "abcd"
	fmt.Printf("cc = %s, type of cc = %T\n", cc, cc)

	//方法四（常用，仅用于函数体内）：省去var关键字，自动匹配
	d := 100
	fmt.Println("d = ", d)
	fmt.Printf("type of d = %T\n", d)

	dd := "abcd"
	fmt.Println("dd = ", dd)
	fmt.Printf("type of dd = %T\n", dd)

	//打印全局变量
	fmt.Println("global_A = ", global_A, ", global_B = ", global_B)
	// fmt.Println("global_C = ", global_C)

	//声明多个变量
	var xx, yy int = 100, 200
	fmt.Println("xx = ", xx, ", yy = ", yy)
	var zz, ss = 300, "abcd"
	fmt.Println("zz = ", zz, ", ss = ", ss)

	//多行多变量声明
	var (
		mm int  = 400
		tt bool = true
	)
	fmt.Println("mm = ", mm, ", tt = ", tt)
}
```

## 03 常量

- const定义枚举。
- const结合iota实现枚举值自增。

```go
/*
	常量。
*/
package main

import "fmt"

const (
	//iota首行为0，此后每行+1
	TEEMO = iota * 10 // TEEMO =  0, iota = 0
	YASUO             // YASUO = 10, iota = 1
	LUX               // LUX   = 20, iota = 2
	ZOE               // ZOE   = 30, iota = 3
)

const (
	a, b = iota + 1, iota + 2 // iota = 0, a = 1, b = 2
	c, d                      // iota = 1, a = 2, b = 3
	e, f                      // iota = 2, a = 3, b = 4
	g, h = iota * 2, iota * 3 // iota = 3, a = 6, b = 9
	i, j                      // iota = 4, a = 8, b = 12
)

func main() {
	// 常量（只读属性）
	const length int = 10
	fmt.Println("length = ", length)
	// length = 100 // 非法：常量无法修改

	fmt.Println("TEEMO = ", TEEMO)
	fmt.Println("YASUO = ", YASUO)
	fmt.Println("LUX = ", LUX)
	fmt.Println("ZOE = ", ZOE)
}
```

## 04 函数

- 匿名返回值。
- 具名返回值。
- 多返回值。

```go
/*
	函数。
*/
package main

import "fmt"

// 匿名返回值
func fun1(a string, b int) int {
	fmt.Println("\n---func1---")
	fmt.Println("a = ", a)
	fmt.Println("b = ", b)

	c := 2333
	return c
}

// 匿名返回值
func fun2(a string, b int) (int, int) {
	fmt.Println("\n---func2---")

	fmt.Println("a = ", a)
	fmt.Println("b = ", b)

	return 2, 333
}

// 具名返回值
func fun3(a string, b int) (ret1 int, ret2 int) {
	fmt.Println("\n---func3---")
	fmt.Println("a = ", a)
	fmt.Println("b = ", b)

	ret1 = 2
	ret2 = 333
	return
}

func main() {
	// fun1
	c := fun1("BOOM", 7)
	fmt.Println("c = ", c)

	// fun2
	ret1, ret2 := fun2("BOOM", 7)
	fmt.Println("ret1 = ", ret1, ", ret2 = ", ret2)

	// fun3
	ret1, ret2 = fun2("BOOM", 7)
	fmt.Println("ret1 = ", ret1, ", ret2 = ", ret2)
}
```

## 05 import导包与init方法调用

- 包内函数名首字母大小写决定对外开放权限：大写（开放）、小写（隐藏）。
- 包匿名别名```_```：不使用该包，只执行其init()方法。
- 包具名别名：
- 通过别名```.```导入全部方法到当前包，无需通过原包名即可调用其方法（慎用）。

目录树：

```
GOPATH
├───bin
├───pkg
└───src
	├───xx_xxxx
	└───05_init
        │   main.go
        ├───lib1
        │       lib1.go
        └───lib2
                lib2.go
```

lib1/lib1.go：

```go
package lib1

import "fmt"

// 函数名首字母大写：对外开放，包外可访问。
func Lib1Test() {
	fmt.Println("lib1.lib1Test()...")
}

// Lib1的初始化函数：对外隐藏，包外不可访问。
func init() {
	fmt.Println("lib1.init()...")
}
```

lib2/lib2.go：

```go
package lib2

import "fmt"

// 函数名首字母大写：对外开放
func Lib2Test() {
	fmt.Println("lib2.lib2Test()...")
}

// Lib2的初始化函数
func init() {
	fmt.Println("lib2.init()...")
}
```

main.go：

```go
/*
	包。
*/

package main

import (
	_ "05_init/lib1"      // 包匿名别名：不使用该包，只执行其init()方法。
	mylib2 "05_init/lib2" // 包具名别名：
	// . "05_init/lib2"   // 导入原包的全部方法到当前包，无需通过原包名调用包中方法（慎用）。
)

func main() {
	// lib1.Lib1Test()
	mylib2.Lib2Test()
}
```

## 06 指针

- go支持二级指针。

```go
/*
	指针：同C++。
*/

package main

import "fmt"

func changeValue(val *int) {
	*val = 100
}

// 交换数值。
func swap(pa, pb *int) {
	var temp int
	temp = *pa
	*pa = *pb
	*pb = temp
}

func main() {
	var val int = 10
	changeValue(&val)
	fmt.Println("a = ", val)

	a, b := 20, 30
	fmt.Println("before swap: a = ", a, ", b = ", b)
	swap(&a, &b)
	fmt.Println("after swap: a = ", a, ", b = ", b)
}
```

## 07 defer

- 多个defer以栈的方式存入（先定义的后执行）。

- defer 与 return执行顺序：return先执行、defer后执行。

```go
/*
	defer：以栈形式存入，程序结束时执行，晚于return。
*/
package main

import "fmt"

func func1() {
	fmt.Println("defer func1 ..")
}

func func2() {
	fmt.Println("defer func2 ..")
}

func func3() {
	fmt.Println("defer func3 ..")
}

func deferFunc() int {
	fmt.Println("defer function called...")
	return 0
}

func returnFunc() int {
	fmt.Println("return function called...")
	return 0
}

// 判断defer与return的执行顺序
func returnAndDefer() int {
	defer deferFunc()
	return returnFunc()
}

func main() {
	// defer：程序结束时执行，多个defer以栈的方式存入（先定义的后执行）
	// 以下执行顺序：func3、func2、func1
	defer func1()
	defer func2()
	defer func3()

	// defer 与 return执行顺序：return先执行、defer后执行。
	returnAndDefer()
}
```

## 08 slice切片（动态数组）

动态数组与静态数组区别：

- 动态数组：引用传递。
- 静态数组：值传递。

声明动态数组的四种方式：

- 方法一：声明并初始化```dymc_arr := []int{1, 2, 3}```
- 方法二：仅声明（不分配空间）```var dymc_arr []int```
- 方法三：声明并分配空间```var dymc_arr = make([]int, 3)```
- 方法四：声明并分配空间，自动推导```dymc_arr := make([]int, 3)```

切片的追加与截取：

- 通过append函数追加元素，扩容因子为2。
- 子切片与父切片指向同一块内存中的数据，修改父切片，子切片随之改变。
- 新建切片，通过copy函数拷贝子切片中的数据。

```go
/*
	切片：动态数组。
*/

package main

import "fmt"

// 打印静态数组（值传递）
func printArray(arr [4]int) {
	for _, value := range arr {
		fmt.Print(value, " ")
	}
	arr[0] = -1 // 不改变实参
	fmt.Println("")
}

// 打印动态数组（引用传递）
func printDynamicArray(arr []int) {
	for _, value := range arr {
		fmt.Print(value, " ")
	}
	arr[0] = -1 // 改变实参
	fmt.Println("")
}

func main() {

	// 静态数组与动态数组的区别
	// 静态数组
	var arr1 [10]int
	arr2 := [10]int{1, 2, 3, 4}
	arr3 := [4]int{11, 22, 33, 44}

	fmt.Printf("arr1: ")
	for i := 0; i < len(arr1); i++ {
		fmt.Printf("%d ", arr1[i])
	}
	fmt.Printf("\n")

	for index, value := range arr2 {
		fmt.Println("arr2 index = ", index, ", value = ", value)
	}

	// 查看静态数组数据类型
	fmt.Printf("type of arr1: %T\n", arr1)
	fmt.Printf("type of arr2: %T\n", arr2)
	fmt.Printf("type of arr3: %T\n", arr3)

	// 打印静态数组
	fmt.Println("===print static array===")
	printArray(arr3)
	printArray(arr3)

	// 动态数组slice
	dynamic_arr_01 := []int{1, 2, 3, 5, 7, 11}
	fmt.Println("===print dynamic array===")
	printDynamicArray(dynamic_arr_01)
	printDynamicArray(dynamic_arr_01)
	// 查看动态数组数据类型
	fmt.Printf("type of dynamic_arr_01: %T\n", dynamic_arr_01)

	// 声明动态数组
	// 方法一：声明并初始化
	// dynamic_arr_02 := []int{1, 2, 3}
	// 方法二：仅声明（不分配空间）
	// var dynamic_arr_02 []int
	// dynamic_arr_02 = make([]int, 3) // 开辟3个空间，默认值为0
	// 方法三：声明并分配空间
	// var dynamic_arr_02 = make([]int, 3)
	// 方法四：声明并分配空间，自动推导
	dynamic_arr_02 := make([]int, 3)
	fmt.Printf("size = %d, capacity = %d, dynamic_arr_02 = %v\n", len(dynamic_arr_02), cap(dynamic_arr_02), dynamic_arr_02) // size = 3, capacity = 3, slice = [0 0 0]

	// 判断切片是否为空
	if dynamic_arr_02 == nil {
		fmt.Println("dynamic_arr_02 is empty!")
	} else {
		fmt.Println("dynamic_arr_02 isn't empty!")
	}

	// 动态数组追加元素
	var numbers = make([]int, 3, 5) // 指定大小和容量

	fmt.Printf("size = %d, capacity = %d, slice = %v\n", len(numbers), cap(numbers), numbers)
	// 追加元素：size = 4, capacity = 5, slice = [0 0 0 1]
	numbers = append(numbers, 1)
	fmt.Printf("size = %d, capacity = %d, slice = %v\n", len(numbers), cap(numbers), numbers)

	// 追加元素：size = 5, capacity = 5, slice = [0 0 0 1 2]
	numbers = append(numbers, 2)
	fmt.Printf("size = %d, capacity = %d, slice = %v\n", len(numbers), cap(numbers), numbers)

	// 追加元素：size = 6, capacity = 10, slice = [0 0 0 1 2 3]
	// 扩容因子：2
	numbers = append(numbers, 3)
	fmt.Printf("size = %d, capacity = %d, slice = %v\n", len(numbers), cap(numbers), numbers)

	// 动态数组截取元素
	dynamic_arr_03 := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 0}
	// 打印原始切片
	fmt.Println("dynamic_arr_03[]: ", dynamic_arr_03)
	// 打印子切片：索引0（包含）到索引4（不包含）
	fmt.Println("dynamic_arr_03[0:4]: ", dynamic_arr_03[0:4])
	// 子切片默认下限为0
	fmt.Println("dynamic_arr_03[ :4]: ", dynamic_arr_03[:4])
	// 子切片默认上限为最后一个索引
	fmt.Println("dynamic_arr_03[ 4:]: ", dynamic_arr_03[4:])

	// 子切片与切片指向同一块内存数据
	dynamic_arr_04 := []int{1, 2, 3}
	dynamic_arr_05 := dynamic_arr_04[0:2]

	dynamic_arr_04[0] = -1
	fmt.Println(dynamic_arr_04)
	fmt.Println(dynamic_arr_05)

	// 拷贝切片内容
	dynamic_arr_06 := make([]int, 3) // 申请新空间然后拷贝
	copy(dynamic_arr_06, dynamic_arr_05)
	dynamic_arr_05[0] = 1
	fmt.Println(dynamic_arr_05)
	fmt.Println(dynamic_arr_06)
}
```

## 09 map

map的三种声明方式：

- 第一种：声明但不申请空间```var mMap1 map[string]string```
- 第二种：声明且申请空间```mMap1 = make(map[string]string, 10)```
- 第三种：声明并初始化```mMap3 := map[string]string{"key" "value", ...}```

增删改查：

map作为参数时引用传递。

map拷贝：新建map变量 => 遍历 => 赋值

```go
package main

import "fmt"

// map传参：引用传递
func printMap(cityMap map[string]string) {
	for key, value := range cityMap {
		fmt.Print("key = ", key)
		fmt.Print(", value =", value)
		fmt.Println()
	}
}

func main() {
	// 第一种声明方法：
	// 声明map类型：key为string，value为string。
	var mMap1 map[string]string

	if mMap1 == nil {
		fmt.Println("mMap1 is empty!")
	}

	// 分配数据空间
	mMap1 = make(map[string]string, 10)

	mMap1["teemo"] = "小可爱"
	mMap1["yasuo"] = "快乐"
	mMap1["zoe"] = "捣蛋鬼"

	// 哈希表：乱序
	fmt.Println(mMap1)

	// 第二种声明方法：
	mMap2 := make(map[int]string)
	mMap2[1] = "teemo"
	mMap2[2] = "yasuo"
	mMap2[3] = "zoe"
	fmt.Println(mMap2)

	// 第三种声明方法：
	mMap3 := map[string]string{
		"one":   "C++",
		"two":   "Python",
		"three": "Go",
	}
	fmt.Println(mMap3)

	cityMap := make(map[string]string)
	// 添加
	cityMap["China"] = "Beijing"
	cityMap["Japan"] = "Tokyo"
	cityMap["UK"] = "London"
	// 删除
	delete(cityMap, "Japan")
	// 修改
	cityMap["Japan"] = "None"
	// 遍历（for-range）
	printMap(cityMap)
	// 拷贝：遍历=>重新赋值
}
```

## 10 OO





































